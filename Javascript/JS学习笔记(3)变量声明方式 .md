# 变量声明方式
变量声明方式有 let和var，声明常量使用 const。
## let
### 基本用法
用法类似于var，用来声明变量，但是所声明的变量只在let命令的代码块内有效。
```
{
  let a = 10;
}
```


### 在for循环中使用let声明 计数器
for循环中的计数器就很合适使用let命令。
```
for (let i = 0;i < 10; i++) {
  // ...
}
console.log(i)
```
计数器i只在for循环体内有效，在循环体外引用就会报错。
此外，设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。

### let命令不存在变量提升
变量提升只发生在“变量提升”现象，即变量可以在声明之前使用，值为undefined。
**let声明的变量一定要在声明之后使用，否则会报错。**
> 变量提升 参照：

### 暂时性死区
只要块级作用域内存在let命令，它所声明的变量就"绑定"在这个区域了。不再受外界的影响。
ES6规定，如果区块中出现let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前使用这些变量，就会报错。
这在语法上，称为**暂时性死区**
```
if(true) {
//TDZ开始
  tmp = 'abc'
  console.log(temp)//ReferenceError
  let tmp;//TDZ结束
  console.log(tmp)//undefined
  tmp =123;
  console.log(tmp)//123
}
```
**暂时性死区对 typeof的影响**
意味着typeof也不是一个百分百安全的操作。
没有let之前，typeof运算符是永远不会报错的，但是现在使用typeof检测未被声明的变量会报ReferenceError。

### 不允许重复声明
let不允许在相同作用域内，重复声明同一个变量。
```
{
  let a= 1;
  let a= 2;//报错
}
```
因此 **不能在函数内部重新声明参数**。

## const
const声明一个只读的常量。一旦声明，常量的值就不能改变。
const一旦声明变量，就必须立即初始化，不能留到以后赋值。
只声明，不赋值，就会报错，报语法错误SyntaxError。
### const声明的常量特点
- 声明之后必须马上赋值
- 不存在变量提升
- 存在暂时性死区 只能在声明之后的位置才能使用
- 不可重复声明

### const声明的本质
const实际上，保证的并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。
对于简单类型得数据(数值，字符串，布尔值)，值就保存在变量指向的那个内存地址，因此等同于常量。
但是对于复杂类型的数据(对象和数组),变量指向的内存地址，保存的只是一个指向实际数据的指针，至于它指向的数据结构是不是可变的，就不能控制的。只是保证这个指针(地址)不变。


## 参考链接
[ECMAScript 6入门](https://es6.ruanyifeng.com/#docs/let)